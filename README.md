# Teodorescu Teodora-Nicola 325CA

## Problema 1: Numarare

Aceasta problema gaseste numarul de lanturi elementare comune intre doua grafuri aciclice orientate. Un lant elementar este un drum in care toate nodurile sunt distincte si exista o muchie orientata de la fiecare nod la urmatorul Ã®n secventa. Primul pas in rezolvarea acestei probleme a fost sa citesc datele din fisierul de input si sa construiesc cele doua grafuri, folosind liste de adiacenta. Mai departe, am construit un graf comun care pastreaza doar muchiile care sunt comune in ambele grafuri, pentru a restrange cautarea. Fiind un graf orientat si aciclic, m am folosit de algoritmul lui Kahn pentru dortarea topologica a grafului comun, pe care am studiat-o la laborator. Acesta functioneaza prin identificarea nodurilor cu muchii cu grad de intrare zero, adaugandu-le intr-o coada si procesandu-le iterativ. Pentru fiecare nod procesat, eliminam muchiile incidente si actualizam gradele de intrare ale vecinilor. Nodurile cu grad de intrare zero sunt adaugate in coada, iar procesul continua pana cand toate nodurile sunt procesate. La final ne returneaza ordinea necesara pentru a calcula numarul de lanturi elementare. Avand aceasta sortare, folosim programare dinamica pentru a afla numarul de drumuri. Numaram lanturile elementare de la nodul initial la nodul final. Pentru fiecare nod in ordinea topologica, actualizam numarul de drumuri pentru vecinii sai, asigurandu-ne ca adunam numarul de drumuri cu modulo. Rezultatul final, care reprezinta numarul de lanturi elementare comune, il pasam fisierului de iesire. Complexitatea algoritmului este O(noduri+muchii).

## Problema 2: Trenuri

Aceasta problema gaseste numarul de orase distincte care pot fi vizitate intre orasul sursa si orasul destinatie. Ideea problemei este de a construi un graf orientat din datele de intrare, sa il sortam topologic pentru a respecta ordinea corecta a vizitarii oraselor si sa folosim programarea dinamica pentru a calcula numarul maxim de orase care pot fi vizitate. Pentru construirea grafului, am folosit lista de adiacenta pe care am reprezentat-o folosind unordered_map, in scopul de a gestiona mai eficient orasele, care sunt date ca string-uri. De asemenea, am un dictionar care foloseste la stocarea datelor de intrare al fiecarui nod. Aplicam algoritmul lui Kahn pentru sortarea topologica a grafului. Algoritmul lui Kahn functioneaza prin identificarea nodurilor fara muchii incidente (grad de intrare zero) si adaugarea lor intr-o coada. Iterativ, eliminam aceste noduri din graf si actualizam gradele de intrare ale vecinilor. Daca un vecin ajunge la grad de intrare zero, il adaugam in coada. In codul nostru, verificam daca un nod are vecini cu if (graph.find(current) != graph.end()) pentru a lucra eficient cu string-uri. Aplicam algoritmul lui Kahn pentru sortarea topologica a grafului. Daca un vecin ajunge la grad de intrare zero, il adaugam in coada. De asemenea, verificam daca un nod are vecini cu "if (graph.find(current) != graph.end())", pentru a lucra eficient cu string-uri. Dupa ce obtinem ordinea topologica a nodurilor, folosim programarea dinamica pentru a calcula numarul maxim de orase distincte. Rezultatul il scriem in fisierul de iesire. Complexitatea algoritmului este O(noduri+muchii).

## Problema 3: Drumuri

Aceasta problema determina suma minima a drumurilor de la 2 noduri sursa, x si y, pana la nodul destinatie, z, intr-un graf orientat cu costuri pe muchii. Pentru a afla afla drumul minim intr-un graf cu costuri pozitive, am ales sa folosesc algoritmul Dijkstra, pe care l-am invatat din laborator. Acesta functioneaza prin initializarea unui vector de distante cu valori infinite si un set de prioritati pentru a gestiona nodurile de procesat. Nodul sursa are distanta initiala 0 si este adaugat in set. Nodurile sunt procesate iterativ, actualizand distantele pentru vecinii lor daca se gaseste un drum mai scurt. Setul de prioritati asigura ca nodurile sunt procesate in ordinea distantelor minime. Acest proces continua pana cand toate nodurile au fost procesate sau setul de prioritati este gol. Aplicam acest algoritm de 2 ori, pentru a afla distanta de la x la z, dar si de la y la z. Dupa aplicarea algoritmului pentru x si y, rezultatul, reprezentand suma minima a drumurilor, este scris in fisierul de iesire. Complexitatea algoritmului este O((noduri+muchii)log(noduri)).
